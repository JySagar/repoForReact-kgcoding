===================Understood react props and imp things=================

-> When we give:
----------------------------------------------------
function App() {
  const [calVal, setCalVal] = useState("");
  const onButtonClickFn = (event) => {
    console.log(event);
  };

  return (
    <div className={styles.calculator}>
      <Display displayValue={calVal}></Display>
      <ButtonsContainer onButtonClick={onButtonClickFn}></ButtonsContainer>
    </div>
  );
}
----------------------------------------------------
        <button
          className={styles.button}
          onClick={onButtonClick}
        >
          {buttonName}
        </button>
----------------------------------------------------
here : it means in case of event. we can just pass the reference of the function just like this line "onClick={onButtonClick}". It means passing the reference of the function which console logs the event.
----------------------------------------------------
function App() {
  const [calVal, setCalVal] = useState("");
  const onButtonClickFn = (buttonText) => {
    console.log(buttonText);
  };

  return (
    <div className={styles.calculator}>
      <Display displayValue={calVal}></Display>
      <ButtonsContainer onButtonClick={onButtonClickFn}></ButtonsContainer>
    </div>
  );
}
----------------------------------------------------
        <button
          className={styles.button}
          onClick={() => onButtonClick(buttonName)}
        >
          {buttonName}
        </button>
----------------------------------------------------
here : we are writing buttonText which is just a variable to store what comes. so when we write the line "onClick={() => onButtonClick(buttonName)}" we need to give buttonName bcoz since its not like event so react don't know what to give so have to give it manually and why we made it a callback function we have discussed below.
----------------------------------------------------
here : onClick={() => onButtonClick(buttonName i.e. "1" or "2" or "etc.")} is called when we click the button on the calc. but if we write: onClick={onButtonClick(buttonName)} i.e. without callback function it will be called when rendered so since it is called without we clicked a button so it will throw error as undefined value is passed.

===================****************===================


===================Understood react props and imp things=================


===================Understood AddTodo.jsx from Project 6=================

----------------------------------------------------------
function AddTodo({ onNewItem }) {
  const [todoName, setTodoName] = useState();
  const [dueDate, setDueDate] = useState();

  const handleNameChange = (event) => {
    setTodoName(event.target.value);
  };
  const handleDateChange = (event) => {
    setDueDate(event.target.value);
  };

  const handleAddButtonClicked = () => {
    onNewItem(todoName, dueDate);
    setTodoName("");
    setDueDate("");
  };

   <div className="col-4">
          <input
            type="text"
            placeholder="Enter Todo Here"
            onChange={handleNameChange}
            value={todoName}
          />
        </div>
        <div className="col-4">
          <input type="date" onChange={handleDateChange} value={dueDate} />
        </div>
        <div className="col-2">
          <button
            type="button"
            className="btn btn-success jy-button"
            onClick={handleAddButtonClicked}
          >
            Add
          </button>
        </div>
      </div>
    </div>
}
-----------------------------------------------------------------

Here when we type in input or set Date the onChange is triggered which is like a doorbell then the main is setTodoName or setDueDate i.e. in handleNameChange and handleDateChange does the work which is re-rendering the component. so since we used useState here so the value we type in the input box stays there. Here after each letter the setTodoName re-renders the component and the setDueDate also does the same. otherwise when we type the letter would not stay if we don't use useState.

-----------------------------------------------------------------
-----------------------------------------------------------------

  const [todoItems, setTodoItems] = useState(initialTodoItems);

  const handleNewItem = (itemName, itemDueDate) => {
    const newTodoItems = [
      ...todoItems,
      { name: itemName, dueDate: itemDueDate },
    ];
    setTodoItems(newTodoItems);
  };

-----------------------------------------------------------------

Here, using state so that when an item is added to the todo list so after saving it or re-rendering when setTodoItems is called the item stays there. Now, here we initialized todoItems with initialTodoItems then when we get the values from addTodo.jsx i.e. itemName and itemDueDate then we created newTodoItems array where we spreaded the todoItems array using three dots and then pushing the object "{ name: itemName, dueDate: itemDueDate }" inside the new array so now it becomes a whole array with new items so now we used setTodoItems(newTodoItems) which re-rendered the app.jsx(and also addTodo.jsx as it is linked with props and function calls with each other) so now we got the todo list updated.


===================Understood AddTodo.jsx from Project 6=================


==========Understood "value={}" from AddTodo.jsx from Project 6============

Here "value={todoName}" and "value={dueDate}" are controlled components. Controlled components is an inpute element like : <input> or <textarea> whose value is controlled by React state. Instead of the browser managing the input internally, React takes control and stores the value in its own memory (useState).

Then, in our input tags : value={todoName} and value={dueDate} means : whatever is in the todoName state, that's what this input should display. So when we type something onChange={handleNameChange} fires : So React updates todoName using setTodoName(...) and that value is immediately reflected back in the input box via value={todoName}.

And one of the main reason is that if when we write something in the input fields or choose the date and press the add button then the input gets empty as clicking on the add button triggers onClick={handleAddButtonClicked} i.e.

"
  const handleAddButtonClicked = () => {
    onNewItem(todoName, dueDate);
    setTodoName("");
    setDueDate("");
  };
"
where setTodoName("")/setDueDate("") runs and cause the component to re-render with empty string of todoName and dueDate which immediately updates (due to re-render) the value of input i.e. empties it. Otherwise if we haven't given value={todoName}/value={dueDate} then even after pressing the add button the previous typed value would not have disappeared from the input fields.

==========Understood "value={}" from AddTodo.jsx from Project 6============


==========Understood "form and inside modifications" from AddTodo.jsx from Project 6============


import { useState } from "react";
import { BiMessageAdd } from "react-icons/bi";

function AddTodo({ onNewItem }) {
  const [todoName, setTodoName] = useState("");
  const [dueDate, setDueDate] = useState("");

  const handleNameChange = (event) => {
    setTodoName(event.target.value);
  };
  const handleDateChange = (event) => {
    setDueDate(event.target.value);
  };

  const handleAddButtonClicked = () => {
    onNewItem(todoName, dueDate);
    setTodoName("");
    setDueDate("");
  };

  return (
    <div className="container">
      <form className="row jy-row">
        <div className="col-4">
          <input
            type="text"
            placeholder="Enter Todo Here"
            onChange={handleNameChange}
            value={todoName}
          />
        </div>
        <div className="col-4">
          <input type="date" onChange={handleDateChange} value={dueDate} />
        </div>
        <div className="col-2">
          <button
            type="button"
            className="btn btn-success jy-button"
            onClick={handleAddButtonClicked}
          >
            <BiMessageAdd />
          </button>
        </div>
      </form>
    </div>
  );
}

export default AddTodo;

---------------------------after update----------------------------

import { useState } from "react";
import { BiMessageAdd } from "react-icons/bi";

function AddTodo({ onNewItem }) {
  const [todoName, setTodoName] = useState("");
  const [dueDate, setDueDate] = useState("");

  const handleNameChange = (event) => {
    setTodoName(event.target.value);
  };
  const handleDateChange = (event) => {
    setDueDate(event.target.value);
  };

  const handleAddButtonClicked = (event) => {
    event.preventDefault();
    onNewItem(todoName, dueDate);
    setTodoName("");
    setDueDate("");
  };

  return (
    <div className="container">
      <form className="row jy-row" onSubmit={handleAddButtonClicked}>
        <div className="col-4">
          <input
            type="text"
            placeholder="Enter Todo Here"
            onChange={handleNameChange}
            value={todoName}
          />
        </div>
        <div className="col-4">
          <input type="date" onChange={handleDateChange} value={dueDate} />
        </div>
        <div className="col-2">
          <button
            // type="button"
            className="btn btn-success jy-button"
            // onClick={handleAddButtonClicked}
          >
            <BiMessageAdd />
          </button>
        </div>
      </form>
    </div>
  );
}

export default AddTodo;

---------------------------------------------------------------

so what we updated here is : we added form tag and when we add form tag the button inside a form become a type={submit} by default and what happen when submitted can be given within the form tag itself. So now we will convert the "onClick={handleAddButtonClicked}" to "onSubmit={handleAddButtonClicked}" and put it inside the form starting tag. Now what happens is when we press the button it i.e. everything in the form is submitted to the server but since we didn't provide any path so the form will pass it by default to our local server i.e. localhost:portnumber. So when submitted to server the page reloads i.e. traditional html behaviour. But we don't want this in react as react only updates the required component. So we added inside the "handleAddButtonClicked" another behaviour i.e. "event.preventDefault()" which will stop the default behaviour of html i.e. reloading.


==========Understood "form and inside modifications" from AddTodo.jsx from Project 6============


==========Understood "useState replaced by useRef" from AddTodo.jsx from Project 6============

write here...............

==========Understood "useState replaced by useRef" from AddTodo.jsx from Project 6============


==========Understood "replacing setTodoItems=(newTodoItems) by setTodoItems(callback fn)" from App.jsx from Project 6============

IN App.jsx:

---------------------------before update----------------------------

  const handleNewItem = (itemName, itemDueDate) => {
    const newTodoItems = [
      ...todoItems,
      { name: itemName, dueDate: itemDueDate },
    ];
    setTodoItems(newTodoItems);
  };

---------------------------after update----------------------------

  const handleNewItem = (itemName, itemDueDate) => {
    setTodoItems((currValue) => {
      const newTodoItems = [
        ...currValue,
        { name: itemName, dueDate: itemDueDate },
      ];
      return newTodoItems;
    });
  };

--------------------------------------------------------------------

We replaced it like that because when we do "setTodoItems(newTodoItems)" then since react need time to update if there are multiple updates happening by like multiple users or putting multiple value at once if this function we make. then after that when setTodoItems run then at that time of run the todoItems maybe wasn't updated to the latest so it might contain old values or case 2: like i updated some thing then it will become a copy during when i am updating then my update will be pasted to the todoItems and if at that time when i was updating someone else was also updating then if his update was completed before mine then when mine was pasted then his update might be replaced by mine. so mine update will lost his work. so it better to use a callback there where here: currValue is an argument here we used this and we might think how the value of todoItems are coming to currValue. In react when we make a callback then its argument of the setTodoItems actually, here react passes the value of todoItems to the argument so it works and since it is a callback so react will give the latest update to the currValue. So it can work in fast updating environments. So before we were doing direct state update and now we are doing functional update which is much better. SO WHEN WE UPDATE A STATE FROM PREVIOUS STATE IT'S SAFER TO DO A FUNCTIONAL UPDATE INSTEAD DIRECT STATE UPDATE TO AVOID STALL VALUES DURING ASYNCHRONOUS UPDATES.

---------------------Now making it even shorter------------------------

---------------------------before update----------------------------

  const handleNewItem = (itemName, itemDueDate) => {
    setTodoItems((currValue) => {
      const newTodoItems = [
        ...currValue,
        { name: itemName, dueDate: itemDueDate },
      ];
      return newTodoItems;
    });
  };

---------------------------after update----------------------------

  const handleNewItem = (itemName, itemDueDate) => {
    setTodoItems((currValue) => [
      ...currValue,
      { name: itemName, dueDate: itemDueDate },
    ]);
  };

-------------------------------------------------------------------

Here it working because : Before we were doing like : creating new array (newTodoItems) with old + new item, then returning that array. But After updating we were doing like : When we write like this it creates a new array immediately and immediately returns it.

🧠 JavaScript Magic:
In arrow functions, if you don’t use { } braces, JavaScript automatically returns whatever comes next. That’s called implicit return.

Summery Explaination : Earlier we used "const newTodoItems" to store the combined array and then we put it in setTodoItems(newTodoItems) so it updated the state. but now we are using setTodoItems() as a function instead storing it in a variable(const newTodoItems) so here since setTodoItems is like whatever it returns the value goes to todoItems. so this time during implicit return the value direct goes to todoItems. 

==========Understood "replacing setTodoItems=(newTodoItems) by setTodoItems(callback fn)" from App.jsx from Project 6============


=============Understood useContext from Project 6 version 5===============

-> createContext([]) --> Create a global context with default value `[]`
-> <Provider value={something}> --> Start sharing `something` (your data) with children
-> useContext(todoItemsContext) --> Get that shared value inside any child component.

-> And remember that whenever the value of context provider i.e. here "todoItemsContext.Provider value={todoItems}" changes then whatever inside it has i.e. the childrens re renders.

-> commit msg : earlier we made state(data stored in the state like here todoItems) and whatever data needed then the state(containing the data) were passed as props to everyone but now after applying context we are making a state(data stored in the state like here todoItems) and passing the state(containing the data) to a context provider and whoever wants that data can access from the context provider.

=============Understood useContext from Project 6 version 5===============


=============Understood useReducer from Project 6 version 5===============

useReducer is a react Hook : const [todoItems, dispatchTodoItems] = useReducer(reducerFn, []);
Here, when we write this : a variable todoItems here getting initialized with empty array i.e. []. Then we got another function here we calling it : dispatch. and one function here named reducerFn which will get called when dispatch function is called. 
Working : 
   const addNewItem = (itemName, itemDueDate) => {
    const addItemAction = {
      type: "NEW_ITEM",
      payload: {
        nameHere: itemName,
        dueDateHere: itemDueDate,
      },
    };

    dispatchTodoItems(addItemAction);
  };

  const deleteItem = (todoItemName) => {
    const deleteItemAction = {
      type: "DELETE_ITEM",
      payload: {
        nameHere: todoItemName,
        // itemDueDate not needed as we are deleting just by seeing the item name.
        // dueDateHere: itemDueDate,
      },
    };
    dispatchTodoItems(deleteItemAction);
  }
  
  Here we defined two functions addNewItem and deleteItem where some parameters itemName and itemDueDate where we getting the values from somewhere else. then inside it another function i.e. here addItemAction and deleteItemAction is setting the type and payload. and then are dispatched using dispatchTodoItems.
  
  On dispatching another function is called automatically i.e. here named reducerFn :

  const reducerFn = (currentTodoItems, action) => {
  let newTodoItems = currentTodoItems;

  if (action.type === "NEW_ITEM") {
    newTodoItems = [
      ...currentTodoItems,
      { name: action.payload.nameHere, dueDate: action.payload.dueDateHere },
    ];
  } else if (action.type === "DELETE_ITEM") {
    newTodoItems = currentTodoItems.filter(
      (item) => item.name !== action.payload.nameHere
    );
  }
  return newTodoItems;
};

Here, reducerFn is accepts two parameters i.e. "currentTodoItems" which gets the value of "todoItems" from "const [todoItems, dispatchTodoItems] = useReducer(reducerFn, []);" and the action is getting the value i.e. been sent by dispatchTodoItems(i.e. here addItemAction and deleteItemAction). then based on these value of a new variable newTodoItems is set and then it is returned at last and when it is returned the todoItems from "const [todoItems, dispatchTodoItems] = useReducer(reducerFn, []);" gets the new items from the reducerFn which is why reducerFn is written in the line : const [todoItems, dispatchTodoItems] = useReducer(reducerFn, []);. and when new value of todoItems is received then the component re-renders.

=============Understood useReducer from Project 6 version 5===============


===========================================================================================
Summery of the new Todo App i.e. 6 number and version 5 :

--------------------------Read this to get the top view------------------------
Another way to understand :
In App.jsx : we have written the components: <AppName />, <AddTodo />, etc inside a component i.e. TodoItemsContextProvider i.e. which is wrapping them.
Then, in todoItemsStore.jsx : we defined the function of the component TodoItemsContextProvider, where the components <AppName />, <AddTodo />, etc are got received inside the children parameter. so then inside the function TodoItemsContextProvider we wrapped the children i.e. <AppName />, <AddTodo />, etc by a context named todoItemsContext using todoItemsContext.Provider where values were passed i.e. todoItems and the two functions which are defined inside the TodoItemsContextProvider function. then next things i.e. inside things can be Understood by reading everything in above.
-------------------------------------------------------------------------------

Here at first we created the context : export const todoItemsContext = createContext([]);
This creates a Context object named todoItemsContext.
It's like creating a big container that allows you to “share” data across multiple components — without manually passing it through every level of the component tree.

Then, in the context we did :

<todoItemsContext.Provider value={{
  todoItemsFromContext: todoItems,
  addNewItemFromContext: addNewItem,
  deleteItemFromContext: deleteItem
}}>
  {children}
</todoItemsContext.Provider>

i.e. here we passed todoItems and the two functions to the to variables in the context.

Then, we made a component i.e. we often call it provider component: const TodoItemsContextProvider = ({ children }) => {} in todoItemsStore.jsx.
This is component we made whose name is TodoItemsContextProvider and the context is inside this component where also the two functions are defined and then passed inside the context.
Here a parameter received i.e. children i.e. it receives the components : <AppName />, <AddTodo />, etc.

Then in App.jsx, we used this component i.e. provider component as a wrapper to wrape the components like <AppName />, <AddTodo />, etc so the passed todoItems and the two functions can be accessed by these components i.e. the components inside the provider component.

Now since Understood a lot of the things now its time to understand : addNewItem, deleteItem i.e. who is getting pointed by whom and how all everything. Here :

So in todoItemsStore.jsx and then inside TodoItemsContextProvider we defined the functions : addNewItem and deleteItem then they are passed inside the value of todoItemsContext.Provider. i.e. :
        todoItemsFromContext: todoItems,
        addNewItemFromContext: addNewItem,
        deleteItemFromContext: deleteItem,
So, todoItemsFromContext is getting pointed by todoItems & addNewItemFromContext is getting pointed by addNewItem & deleteItemFromContext is getting pointed by deleteItem. and then inside of AddTodo.jsx we made obj of useContext(todoItemsContext) i.e. contextObj and from it we took out addNewItemFromContext which is pointing a variable i.e. addNewItemHere. So its like :

todoItemsFromContext -> todoItems (don't know where the poiting goes next)

addNewItemFromContext-->addNewItem-->addNewItemHere

deleteItemFromContext-->deleteItem-->deleteItemHere (from TodoItem.jsx)

========================================================================================