===================Understood react props and imp things=================

-> When we give:
----------------------------------------------------
function App() {
  const [calVal, setCalVal] = useState("");
  const onButtonClickFn = (event) => {
    console.log(event);
  };

  return (
    <div className={styles.calculator}>
      <Display displayValue={calVal}></Display>
      <ButtonsContainer onButtonClick={onButtonClickFn}></ButtonsContainer>
    </div>
  );
}
----------------------------------------------------
        <button
          className={styles.button}
          onClick={onButtonClick}
        >
          {buttonName}
        </button>
----------------------------------------------------
here : it means in case of event. we can just pass the reference of the function just like this line "onClick={onButtonClick}". It means passing the reference of the function which console logs the event.
----------------------------------------------------
function App() {
  const [calVal, setCalVal] = useState("");
  const onButtonClickFn = (buttonText) => {
    console.log(buttonText);
  };

  return (
    <div className={styles.calculator}>
      <Display displayValue={calVal}></Display>
      <ButtonsContainer onButtonClick={onButtonClickFn}></ButtonsContainer>
    </div>
  );
}
----------------------------------------------------
        <button
          className={styles.button}
          onClick={() => onButtonClick(buttonName)}
        >
          {buttonName}
        </button>
----------------------------------------------------
here : we are writing buttonText which is just a variable to store what comes. so when we write the line "onClick={() => onButtonClick(buttonName)}" we need to give buttonName bcoz since its not like event so react don't know what to give so have to give it manually and why we made it a callback function we have discussed below.
----------------------------------------------------
here : onClick={() => onButtonClick(buttonName i.e. "1" or "2" or "etc.")} is called when we click the button on the calc. but if we write: onClick={onButtonClick(buttonName)} i.e. without callback function it will be called when rendered so since it is called without we clicked a button so it will throw error as undefined value is passed.

===================****************===================


===================Understood react props and imp things=================


===================Understood AddTodo.jsx from Project 6=================

----------------------------------------------------------
function AddTodo({ onNewItem }) {
  const [todoName, setTodoName] = useState();
  const [dueDate, setDueDate] = useState();

  const handleNameChange = (event) => {
    setTodoName(event.target.value);
  };
  const handleDateChange = (event) => {
    setDueDate(event.target.value);
  };

  const handleAddButtonClicked = () => {
    onNewItem(todoName, dueDate);
    setTodoName("");
    setDueDate("");
  };

   <div className="col-4">
          <input
            type="text"
            placeholder="Enter Todo Here"
            onChange={handleNameChange}
            value={todoName}
          />
        </div>
        <div className="col-4">
          <input type="date" onChange={handleDateChange} value={dueDate} />
        </div>
        <div className="col-2">
          <button
            type="button"
            className="btn btn-success jy-button"
            onClick={handleAddButtonClicked}
          >
            Add
          </button>
        </div>
      </div>
    </div>
}
-----------------------------------------------------------------

Here when we type in input or set Date the onChange is triggered which is like a doorbell then the main is setTodoName or setDueDate i.e. in handleNameChange and handleDateChange does the work which is re-rendering the component. so since we used useState here so the value we type in the input box stays there. Here after each letter the setTodoName re-renders the component and the setDueDate also does the same. otherwise when we type the letter would not stay if we don't use useState.

-----------------------------------------------------------------
-----------------------------------------------------------------

  const [todoItems, setTodoItems] = useState(initialTodoItems);

  const handleNewItem = (itemName, itemDueDate) => {
    const newTodoItems = [
      ...todoItems,
      { name: itemName, dueDate: itemDueDate },
    ];
    setTodoItems(newTodoItems);
  };

-----------------------------------------------------------------

Here, using state so that when an item is added to the todo list so after saving it or re-rendering when setTodoItems is called the item stays there. Now, here we initialized todoItems with initialTodoItems then when we get the values from addTodo.jsx i.e. itemName and itemDueDate then we created newTodoItems array where we spreaded the todoItems array using three dots and then pushing the object "{ name: itemName, dueDate: itemDueDate }" inside the new array so now it becomes a whole array with new items so now we used setTodoItems(newTodoItems) which re-rendered the app.jsx(and also addTodo.jsx as it is linked with props and function calls with each other) so now we got the todo list updated.


===================Understood AddTodo.jsx from Project 6=================


==========Understood "value={}" from AddTodo.jsx from Project 6============

Here "value={todoName}" and "value={dueDate}" are controlled components. Controlled components is an inpute element like : <input> or <textarea> whose value is controlled by React state. Instead of the browser managing the input internally, React takes control and stores the value in its own memory (useState).

Then, in our input tags : value={todoName} and value={dueDate} means : whatever is in the todoName state, that's what this input should display. So when we type something onChange={handleNameChange} fires : So React updates todoName using setTodoName(...) and that value is immediately reflected back in the input box via value={todoName}.

And one of the main reason is that if when we write something in the input fields or choose the date and press the add button then the input gets empty as clicking on the add button triggers onClick={handleAddButtonClicked} i.e.

"
  const handleAddButtonClicked = () => {
    onNewItem(todoName, dueDate);
    setTodoName("");
    setDueDate("");
  };
"
where setTodoName("")/setDueDate("") runs and cause the component to re-render with empty string of todoName and dueDate which immediately updates (due to re-render) the value of input i.e. empties it. Otherwise if we haven't given value={todoName}/value={dueDate} then even after pressing the add button the previous typed value would not have disappeared from the input fields.

==========Understood "value={}" from AddTodo.jsx from Project 6============


==========Understood "form and inside modifications" from AddTodo.jsx from Project 6============


import { useState } from "react";
import { BiMessageAdd } from "react-icons/bi";

function AddTodo({ onNewItem }) {
  const [todoName, setTodoName] = useState("");
  const [dueDate, setDueDate] = useState("");

  const handleNameChange = (event) => {
    setTodoName(event.target.value);
  };
  const handleDateChange = (event) => {
    setDueDate(event.target.value);
  };

  const handleAddButtonClicked = () => {
    onNewItem(todoName, dueDate);
    setTodoName("");
    setDueDate("");
  };

  return (
    <div className="container">
      <form className="row jy-row">
        <div className="col-4">
          <input
            type="text"
            placeholder="Enter Todo Here"
            onChange={handleNameChange}
            value={todoName}
          />
        </div>
        <div className="col-4">
          <input type="date" onChange={handleDateChange} value={dueDate} />
        </div>
        <div className="col-2">
          <button
            type="button"
            className="btn btn-success jy-button"
            onClick={handleAddButtonClicked}
          >
            <BiMessageAdd />
          </button>
        </div>
      </form>
    </div>
  );
}

export default AddTodo;

---------------------------after update----------------------------

import { useState } from "react";
import { BiMessageAdd } from "react-icons/bi";

function AddTodo({ onNewItem }) {
  const [todoName, setTodoName] = useState("");
  const [dueDate, setDueDate] = useState("");

  const handleNameChange = (event) => {
    setTodoName(event.target.value);
  };
  const handleDateChange = (event) => {
    setDueDate(event.target.value);
  };

  const handleAddButtonClicked = (event) => {
    event.preventDefault();
    onNewItem(todoName, dueDate);
    setTodoName("");
    setDueDate("");
  };

  return (
    <div className="container">
      <form className="row jy-row" onSubmit={handleAddButtonClicked}>
        <div className="col-4">
          <input
            type="text"
            placeholder="Enter Todo Here"
            onChange={handleNameChange}
            value={todoName}
          />
        </div>
        <div className="col-4">
          <input type="date" onChange={handleDateChange} value={dueDate} />
        </div>
        <div className="col-2">
          <button
            // type="button"
            className="btn btn-success jy-button"
            // onClick={handleAddButtonClicked}
          >
            <BiMessageAdd />
          </button>
        </div>
      </form>
    </div>
  );
}

export default AddTodo;

---------------------------------------------------------------

so what we updated here is : we added form tag and when we add form tag the button inside a form become a type={submit} by default and what happen when submitted can be given within the form tag itself. So now we will convert the "onClick={handleAddButtonClicked}" to "onSubmit={handleAddButtonClicked}" and put it inside the form starting tag. Now what happens is when we press the button it i.e. everything in the form is submitted to the server but since we didn't provide any path so the form will pass it by default to our local server i.e. localhost:portnumber. So when submitted to server the page reloads i.e. traditional html behaviour. But we don't want this in react as react only updates the required component. So we added inside the "handleAddButtonClicked" another behaviour i.e. "event.preventDefault()" which will stop the default behaviour of html i.e. reloading.


==========Understood "form and inside modifications" from AddTodo.jsx from Project 6============


==========Understood "useState replaced by useRef" from AddTodo.jsx from Project 6============

write here...............

==========Understood "useState replaced by useRef" from AddTodo.jsx from Project 6============


==========Understood "replacing setTodoItems=(newTodoItems) by setTodoItems(callback fn)" from App.jsx from Project 6============

IN App.jsx:

---------------------------before update----------------------------

  const handleNewItem = (itemName, itemDueDate) => {
    const newTodoItems = [
      ...todoItems,
      { name: itemName, dueDate: itemDueDate },
    ];
    setTodoItems(newTodoItems);
  };

---------------------------after update----------------------------

  const handleNewItem = (itemName, itemDueDate) => {
    setTodoItems((currValue) => {
      const newTodoItems = [
        ...currValue,
        { name: itemName, dueDate: itemDueDate },
      ];
      return newTodoItems;
    });
  };

--------------------------------------------------------------------

We replaced it like that because when we do "setTodoItems(newTodoItems)" then since react need time to update if there are multiple updates happening by like multiple users or putting multiple value at once if this function we make. then after that when setTodoItems run then at that time of run the todoItems maybe wasn't updated to the latest so it might contain old values or case 2: like i updated some thing then it will become a copy during when i am updating then my update will be pasted to the todoItems and if at that time when i was updating someone else was also updating then if his update was completed before mine then when mine was pasted then his update might be replaced by mine. so mine update will lost his work. so it better to use a callback there where here: currValue is an argument here we used this and we might think how the value of todoItems are coming to currValue. In react when we make a callback then its argument of the setTodoItems actually, here react passes the value of todoItems to the argument so it works and since it is a callback so react will give the latest update to the currValue. So it can work in fast updating environments. So before we were doing direct state update and now we are doing functional update which is much better. SO WHEN WE UPDATE A STATE FROM PREVIOUS STATE IT'S SAFER TO DO A FUNCTIONAL UPDATE INSTEAD DIRECT STATE UPDATE TO AVOID STALL VALUES DURING ASYNCHRONOUS UPDATES.

---------------------Now making it even shorter------------------------

---------------------------before update----------------------------

  const handleNewItem = (itemName, itemDueDate) => {
    setTodoItems((currValue) => {
      const newTodoItems = [
        ...currValue,
        { name: itemName, dueDate: itemDueDate },
      ];
      return newTodoItems;
    });
  };

---------------------------after update----------------------------

  const handleNewItem = (itemName, itemDueDate) => {
    setTodoItems((currValue) => [
      ...currValue,
      { name: itemName, dueDate: itemDueDate },
    ]);
  };

-------------------------------------------------------------------

Here it working because : Before we were doing like : creating new array (newTodoItems) with old + new item, then returning that array. But After updating we were doing like : When we write like this it creates a new array immediately and immediately returns it.

ðŸ§  JavaScript Magic:
In arrow functions, if you donâ€™t use { } braces, JavaScript automatically returns whatever comes next. Thatâ€™s called implicit return.

==========Understood "replacing setTodoItems=(newTodoItems) by setTodoItems(callback fn)" from App.jsx from Project 6============

